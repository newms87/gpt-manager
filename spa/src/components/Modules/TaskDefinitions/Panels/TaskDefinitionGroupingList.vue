<template>
	<div class="bg-slate-800 p-4 rounded">
		<div class="flex">
			<div class="pr-4 py-4">Grouping Mode:</div>
			<QTabs
				class="tab-buttons border-sky-900"
				indicator-color="sky-900"
				:model-value="taskDefinition.grouping_mode"
				@update:model-value="grouping_mode => updateAction.trigger(taskDefinition, {grouping_mode})"
			>
				<QTab name="Concatenate" label="Concatenate" />
				<QTab name="Merge" label="Merge" />
				<QTab name="Overwrite" label="Overwrite" />
				<QTab name="Split" label="Split" />
			</QTabs>
			<QCheckbox
				class="ml-8"
				:model-value="taskDefinition.split_by_file"
				label="Split by file"
				@update:model-value="split_by_file => updateAction.trigger(taskDefinition, {split_by_file})"
			/>
			<QCheckbox
				class="ml-8"
				:model-value="!!taskDefinition.groupingFragments"
				label="Group by keys"
				@update:model-value="addGroupingKey"
			/>
		</div>
		<div v-if="taskDefinition.grouping_keys" class="mt-4">
			<div v-for="(groupingKey, index) in taskDefinition.grouping_keys" :key="index" class="flex items-center">
				<SchemaEditorToolbox
					can-select
					can-select-fragment
					previewable
					:loading="updateAction.isApplying"
					:model-value="resolveSchemaDefinition(groupingKey.schema_definition_id)"
					:fragment="groupingKey"
					@update:model-value="schemaDefinition => updateAction.trigger(taskDefinition, {grouping_keys: taskDefinition.grouping_keys})"
				/>
			</div>
			<ActionButton
				v-if="unusedSchemaDefinitions.length > 0"
				type="create"
				color="green"
				label="Add Grouping Key"
				@click="addGroupingKey"
			/>
		</div>
	</div>
</template>
<script setup lang="ts">
import SchemaEditorToolbox from "@/components/Modules/SchemaEditor/SchemaEditorToolbox";
import { dxSchemaDefinition } from "@/components/Modules/Schemas/SchemaDefinitions";
import { dxTaskDefinition } from "@/components/Modules/TaskDefinitions";
import { ActionButton } from "@/components/Shared";
import { TaskDefinition } from "@/types";
import { computed } from "vue";

const props = defineProps<{
	taskDefinition: TaskDefinition,
}>();

const updateAction = dxTaskDefinition.getAction("update");

// Unused schemas are the remaining schemas that are not already added to the list of group keys
const unusedSchemaDefinitions = computed(() => {
	const unused = [];
	for (let schema of dxSchemaDefinition.pagedItems.value?.data || []) {
		console.log("check", schema);
		if (!props.taskDefinition.groupingFragments.find(gf => gf.schema.id === schema.id)) {
			unused.push(schema);
		}
	}
	return unused;
});

/**
 *  Resolve the schema by its id
 */
function resolveSchemaDefinition(schemaDefinitionId) {
	return (dxSchemaDefinition.pagedItems.value?.data || []).find(schema => schema.id === schemaDefinitionId);
}

/**
 *  Add a new grouping key to the task definition w/ the first available schema
 */
function addGroupingKey() {
	if (unusedSchemaDefinitions.value.length === 0) {
		return;
	}

	// TODO: consider allowing one-off selections of fragments (ie: schema_associations.fragment_selector field optional instead of a fragment_id)

	// TODO: HEREEEEEE needs to be reworked to modify schema associations directly
	const groupingKeys = props.taskDefinition.groupingFragments || [];
	groupingKeys.push({ schema_definition_id: unusedSchemaDefinitions.value[0].id });
	updateAction.trigger(props.taskDefinition, { grouping_keys: groupingKeys });
}
</script>
