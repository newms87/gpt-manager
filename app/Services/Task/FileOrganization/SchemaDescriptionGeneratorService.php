<?php

namespace App\Services\Task\FileOrganization;

use App\Api\AgentApiContracts\AgentApiContract;
use App\Api\Options\ResponsesApiOptions;
use App\Models\Task\TaskDefinition;
use Newms87\Danx\Traits\HasDebugLogging;
use Exception;
use Illuminate\Support\Facades\Cache;
use Newms87\Danx\Exceptions\LockException;
use Newms87\Danx\Helpers\LockHelper;

/**
 * Generates dynamic JSON schema descriptions based on TaskDefinition prompts.
 * Uses LLM to create context-specific descriptions with caching.
 */
class SchemaDescriptionGeneratorService
{
    use HasDebugLogging;

    public const int CACHE_TTL_SECONDS = 2592000; // 30 days

    public const string CACHE_PREFIX = 'file_org_schema_descs';

    public const array DEFAULT_DESCRIPTIONS = [
        'name'       => 'Name of this group (e.g., "Section A", "Category 1", "Entity Name"). Use empty string "" if no clear identifier exists.',
        'confidence' => 'How confident are you in the group name? 0=cannot determine, 5=highly confident',
    ];

    /**
     * Get or generate schema descriptions for a TaskDefinition.
     * Returns both name and confidence descriptions in a single LLM call.
     * Uses cache with 30-day TTL and LockHelper to prevent duplicate LLM calls.
     * Falls back to defaults on any error.
     *
     * @return array{name: string, confidence: string}
     */
    public function getSchemaDescriptions(TaskDefinition $taskDefinition): array
    {
        static::logDebug("Getting schema descriptions for TaskDefinition {$taskDefinition->id}");

        try {
            $cacheKey = $this->getCacheKey($taskDefinition);
            static::logDebug("Cache key: $cacheKey");

            // Try to get from cache first (fast path - no lock needed)
            $cached = Cache::get($cacheKey);
            if ($cached !== null) {
                static::logDebug('Cache hit - returning cached descriptions');

                return $cached;
            }

            // Cache miss - need to generate, use lock to prevent concurrent generation
            $lockKey = 'schema_descs_gen:' . $cacheKey;

            try {
                // Acquire lock - will wait up to 31 seconds for other jobs to finish
                LockHelper::acquire($lockKey, 31, 60);

                // Double-check cache after acquiring lock (another job may have generated it)
                $cached = Cache::get($cacheKey);
                if ($cached !== null) {
                    static::logDebug('Schema descriptions generated by another job while waiting for lock');

                    return $cached;
                }

                // We have the lock and cache is empty - generate descriptions
                static::logDebug('Generating schema descriptions (lock acquired)');
                $descriptions = $this->generateDescriptions($taskDefinition);

                // Store in cache
                Cache::put($cacheKey, $descriptions, static::CACHE_TTL_SECONDS);
                static::logDebug('Cached descriptions for 30 days');

                return $descriptions;
            } catch (LockException $e) {
                // Lock timeout - fall back to default descriptions
                static::logError('Lock timeout while generating schema descriptions', [
                    'cache_key' => $cacheKey,
                    'error'     => $e->getMessage(),
                ]);

                return static::DEFAULT_DESCRIPTIONS;
            } finally {
                // Always release the lock
                LockHelper::release($lockKey);
            }
        } catch (Exception $e) {
            static::logDebug("Error generating descriptions: {$e->getMessage()} - falling back to defaults");

            return static::DEFAULT_DESCRIPTIONS;
        }
    }

    /**
     * Generate cache key from TaskDefinition prompt.
     * Uses MD5 hash of prompt for consistent key generation.
     */
    protected function getCacheKey(TaskDefinition $taskDefinition): string
    {
        $prompt = $taskDefinition->prompt ?? '';
        $hash   = md5($prompt);

        return static::CACHE_PREFIX . ':' . $hash;
    }

    /**
     * Generate schema descriptions using LLM in a single request.
     * Uses model and timeout from config instead of TaskDefinition agent.
     *
     * @return array{name: string, confidence: string}
     *
     * @throws Exception if generation fails
     */
    protected function generateDescriptions(TaskDefinition $taskDefinition): array
    {
        static::logDebug('Generating descriptions via LLM');

        // Get model and timeout from config
        $modelName = config('ai.file_organization_schema.model');
        $timeout   = config('ai.file_organization_schema.timeout');

        static::logDebug("Using model: {$modelName}");

        // Build the LLM prompt
        $llmPrompt = $this->buildLlmPrompt($taskDefinition);

        try {
            // Get the model API from config
            $api = $this->getModelApi($modelName);

            // Build messages array
            $messages = [
                [
                    'role'    => 'user',
                    'content' => $llmPrompt,
                ],
            ];

            static::logDebug("Calling LLM API with timeout: {$timeout}s");

            // Build API options
            $options = new ResponsesApiOptions([
                'timeout'     => $timeout,
                'temperature' => 0.3, // Lower temperature for more consistent output
            ]);
            $options->setDefaultTextFormat();

            // Call the LLM using the responses API
            $response = $api->responses($modelName, $messages, $options);

            static::logDebug('LLM response received');

            // Extract JSON from response
            $content = trim($response->getContent() ?? '');

            if (empty($content)) {
                static::logDebug('Empty response from LLM - using defaults');

                return static::DEFAULT_DESCRIPTIONS;
            }

            // Parse JSON response
            $parsed = json_decode($content, true);

            if (json_last_error() !== JSON_ERROR_NONE || !is_array($parsed)) {
                static::logDebug('Invalid JSON response from LLM - using defaults. JSON error: ' . json_last_error_msg());
                static::logDebug('Response content: ' . substr($content, 0, 200));

                return static::DEFAULT_DESCRIPTIONS;
            }

            // Extract descriptions from parsed JSON
            $nameDescription       = $parsed['name_description']       ?? null;
            $confidenceDescription = $parsed['confidence_description'] ?? null;

            // Validate both descriptions exist and are non-empty strings
            if (empty($nameDescription) || empty($confidenceDescription)) {
                static::logDebug('Missing or empty descriptions in LLM response - using defaults');

                return static::DEFAULT_DESCRIPTIONS;
            }

            static::logDebug('Generated name description: ' . substr($nameDescription, 0, 100) . '...');
            static::logDebug('Generated confidence description: ' . substr($confidenceDescription, 0, 100) . '...');

            return [
                'name'       => $nameDescription,
                'confidence' => $confidenceDescription,
            ];
        } catch (Exception $e) {
            static::logDebug("LLM call failed: {$e->getMessage()}");
            throw $e;
        }
    }

    /**
     * Build LLM prompt for generating both schema descriptions in a single request.
     * Template requests JSON output with both name and confidence descriptions.
     */
    protected function buildLlmPrompt(TaskDefinition $taskDefinition): string
    {
        $taskPrompt = $taskDefinition->prompt ?? '';

        return <<<PROMPT
You are helping generate JSON schema descriptions for a file organization task.

The task definition prompt is:
---
$taskPrompt
---

Generate descriptions for TWO fields. Return your response as valid JSON with this exact structure:

{
  "name_description": "Description for the group_name field - what kind of names should be used for grouping files. 1-3 sentences with examples. Mention empty string for unclear cases.",
  "confidence_description": "Description for the group_name_confidence field (0-5 scale) - what different confidence levels mean for this task. 1-3 sentences explaining 0, low (1-2), medium (3), high (4-5) with task-specific examples."
}

Requirements:
- name_description: Should explain what kind of group names to use (1-3 sentences, provide task-specific examples, mention empty string "" for unclear cases)
- confidence_description: Should explain what confidence levels 0-5 mean for THIS SPECIFIC TASK (1-3 sentences, give examples of what 0, 1-2, 3, 4-5 represent in this context)
- Return ONLY valid JSON, no markdown formatting, no code blocks
- Use plain text within the JSON values (no markdown, no excessive quotes)

Generate the JSON now:
PROMPT;
    }

    /**
     * Clear cache for a specific TaskDefinition.
     * Useful when task prompt changes.
     */
    public function clearCache(TaskDefinition $taskDefinition): void
    {
        $cacheKey = $this->getCacheKey($taskDefinition);
        Cache::forget($cacheKey);
        static::logDebug("Cleared cache for TaskDefinition {$taskDefinition->id}");
    }

    /**
     * Clear all cached schema descriptions.
     * Useful for cache maintenance or when changing generation logic.
     */
    public function clearAllCache(): void
    {
        // Since we use MD5 hashes, we can't easily iterate all keys
        // This method would require a Redis SCAN or similar pattern matching
        // For now, document that individual cache entries will expire after 30 days
        static::logDebug('Note: Individual cache entries expire after 30 days. To force regeneration, call clearCache() for specific TaskDefinitions.');
    }

    /**
     * Get the model API instance from config.
     *
     * @throws Exception if model config or API class not found
     */
    protected function getModelApi(string $modelName): AgentApiContract
    {
        $modelConfig = config('ai.models.' . $modelName);

        if (!$modelConfig) {
            throw new Exception("Model config not found for: {$modelName}");
        }

        $apiClass = $modelConfig['api'] ?? null;

        if (!$apiClass) {
            throw new Exception("API class not found for model: {$modelName}");
        }

        return app($apiClass);
    }
}
