<?php

namespace App\Services\Task\FileOrganization;

use App\Api\Options\ResponsesApiOptions;
use App\Models\Task\TaskDefinition;
use App\Traits\HasDebugLogging;
use Exception;
use Illuminate\Support\Facades\Cache;
use Newms87\Danx\Exceptions\LockException;
use Newms87\Danx\Helpers\LockHelper;

/**
 * Generates dynamic JSON schema name descriptions based on TaskDefinition prompts.
 * Uses LLM to create context-specific descriptions with caching.
 */
class SchemaDescriptionGeneratorService
{
    use HasDebugLogging;

    public const int CACHE_TTL_SECONDS = 2592000; // 30 days

    public const int LLM_TIMEOUT_SECONDS = 30;

    public const string CACHE_PREFIX = 'file_org_schema_desc';

    public const string DEFAULT_DESCRIPTION = 'Name of this group (e.g., "Section A", "Category 1", "Entity Name"). Use empty string "" if no clear identifier exists.';

    /**
     * Get or generate schema name description for a TaskDefinition.
     * Uses cache with 30-day TTL and LockHelper to prevent duplicate LLM calls.
     * Falls back to default on any error.
     */
    public function getSchemaNameDescription(TaskDefinition $taskDefinition): string
    {
        static::logDebug("Getting schema name description for TaskDefinition {$taskDefinition->id}");

        try {
            $cacheKey = $this->getCacheKey($taskDefinition);
            static::logDebug("Cache key: $cacheKey");

            // Try to get from cache first (fast path - no lock needed)
            $cached = Cache::get($cacheKey);
            if ($cached !== null) {
                static::logDebug('Cache hit - returning cached description');

                return $cached;
            }

            // Cache miss - need to generate, use lock to prevent concurrent generation
            $lockKey = 'schema_desc_gen:' . $cacheKey;

            try {
                // Acquire lock - will wait up to 31 seconds for other jobs to finish
                LockHelper::acquire($lockKey, 31, 60);

                // Double-check cache after acquiring lock (another job may have generated it)
                $cached = Cache::get($cacheKey);
                if ($cached !== null) {
                    static::logDebug('Schema name description generated by another job while waiting for lock');

                    return $cached;
                }

                // We have the lock and cache is empty - generate description
                static::logDebug('Generating schema name description (lock acquired)');
                $description = $this->generateDescription($taskDefinition);

                // Store in cache
                Cache::put($cacheKey, $description, static::CACHE_TTL_SECONDS);
                static::logDebug('Cached description for 30 days');

                return $description;
            } catch (LockException $e) {
                // Lock timeout - fall back to default description
                static::logError('Lock timeout while generating schema description', [
                    'cache_key' => $cacheKey,
                    'error'     => $e->getMessage(),
                ]);

                return $this->getDefaultDescription();
            } finally {
                // Always release the lock
                LockHelper::release($lockKey);
            }
        } catch (Exception $e) {
            static::logDebug("Error generating description: {$e->getMessage()} - falling back to default");

            return $this->getDefaultDescription();
        }
    }

    /**
     * Generate cache key from TaskDefinition prompt.
     * Uses MD5 hash of prompt for consistent key generation.
     */
    protected function getCacheKey(TaskDefinition $taskDefinition): string
    {
        $prompt = $taskDefinition->prompt ?? '';
        $hash   = md5($prompt);

        return static::CACHE_PREFIX . ':' . $hash;
    }

    /**
     * Generate schema name description using LLM.
     * Calls TaskDefinition agent with specific prompt template.
     *
     * @throws Exception if generation fails
     */
    protected function generateDescription(TaskDefinition $taskDefinition): string
    {
        static::logDebug('Generating description via LLM');

        // Get the agent from the task definition
        $agent = $taskDefinition->agent;
        if (!$agent) {
            static::logDebug('No agent found - using default description');

            return static::DEFAULT_DESCRIPTION;
        }

        static::logDebug("Using agent: {$agent->name}");

        // Build the LLM prompt
        $llmPrompt = $this->buildLlmPrompt($taskDefinition);

        try {
            // Get the agent's API interface
            $api = $agent->getModelApi();

            // Build messages array
            $messages = [
                [
                    'role'    => 'user',
                    'content' => $llmPrompt,
                ],
            ];

            static::logDebug('Calling LLM API with timeout: ' . static::LLM_TIMEOUT_SECONDS . 's');

            // Build API options
            $options = new ResponsesApiOptions([
                'timeout'     => static::LLM_TIMEOUT_SECONDS,
                'temperature' => 0.3, // Lower temperature for more consistent output
            ]);
            $options->setDefaultTextFormat();

            // Call the LLM using the responses API
            $response = $api->responses($agent->model, $messages, $options);

            static::logDebug('LLM response received');

            // Extract description from response
            $description = trim($response->getContent() ?? '');

            if (empty($description)) {
                static::logDebug('Empty response from LLM - using default');

                return static::DEFAULT_DESCRIPTION;
            }

            static::logDebug('Generated description: ' . substr($description, 0, 100) . '...');

            return $description;
        } catch (Exception $e) {
            static::logDebug("LLM call failed: {$e->getMessage()}");
            throw $e;
        }
    }

    /**
     * Build LLM prompt for generating schema description.
     * Template based on architect specifications.
     */
    protected function buildLlmPrompt(TaskDefinition $taskDefinition): string
    {
        $taskPrompt = $taskDefinition->prompt ?? '';

        return <<<PROMPT
You are helping generate a JSON schema description for a file organization task.

The task definition prompt is:
---
$taskPrompt
---

Based on this task prompt, generate a clear, concise description for the "name" field in the JSON schema.
This description should help the AI understand what kind of group names to use when organizing files.

The description should:
1. Be 1-3 sentences maximum
2. Provide specific examples relevant to this task
3. Mention that empty string "" can be used if no clear identifier exists
4. Be formatted as plain text (no markdown, no quotes around the entire response)

Example format: "Name of this group (e.g., [task-specific examples]). Use empty string \"\" if no clear identifier exists."

Generate the description now:
PROMPT;
    }

    /**
     * Clear cache for a specific TaskDefinition.
     * Useful when task prompt changes.
     */
    public function clearCache(TaskDefinition $taskDefinition): void
    {
        $cacheKey = $this->getCacheKey($taskDefinition);
        Cache::forget($cacheKey);
        static::logDebug("Cleared cache for TaskDefinition {$taskDefinition->id}");
    }

    /**
     * Clear all cached schema descriptions.
     * Useful for cache maintenance or when changing generation logic.
     */
    public function clearAllCache(): void
    {
        // Since we use MD5 hashes, we can't easily iterate all keys
        // This method would require a Redis SCAN or similar pattern matching
        // For now, document that individual cache entries will expire after 30 days
        static::logDebug('Note: Individual cache entries expire after 30 days. To force regeneration, call clearCache() for specific TaskDefinitions.');
    }

    /**
     * Get the default description for schema name field.
     * Used as fallback when generation fails or times out.
     */
    protected function getDefaultDescription(): string
    {
        return static::DEFAULT_DESCRIPTION;
    }
}
